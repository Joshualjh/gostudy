고루틴은 고에서 가지고 있는 경량 쓰레드
메인 함수도 메인 고루틴이라고 부른다.
새로운 고루틴은 단순하게 go 함수_호출로 만든다.
sync.WitGoup을 통해서 싱크를 맞출 수 있다.

고루틴 != 쓰래드
고루틴은 쓰래드를 이용한다

-------------------------------
코어 2 고루틴 1
코어1 -> os쓰래드1 -> 고루틴1

코어 2 고루틴 2
코어1 -> os쓰래드1 -> 고루틴1
코어2 -> os쓰래드2 -> 고루틴2

코어 2 고루틴 3
코어1 -> os쓰래드1 -> 고루틴1
코어2 -> os쓰래드2 -> 고루틴2
고루틴3 대기 -> 먼저 끝난 고루틴이 제거되면 그 자리로 이동하여 고루틴을 진행

아무리 많은 고루틴을 생성해도 컨텍스트 스위칭 비용이 발생하지 않는다. 
-> 아에 발생하지 않는 것은 아니다. 고루틴의 컨텍스트는 매우 경량이기 때문에 
-> os 쓰래드가 컨텍스트 스위칭이 일어나는 것보다 매우 적다
----------------------------------

동시성 프로그래밍의 주의점
동일한 메모리 자원을 여러 고루틴에서 접근할때 동시성 문제가 발생한다.
동시에 여러 루틴에서 같은 주소값을 가져와 수정을 하며 문제가 발생한다.
이를 해결하려면 메모리 자원은 하나의 고루틴에서만 접근하도록 하게 한다.
뮤텍스를 이용하여 lock을 건다. -- 상호배제

뮤텍스 문제점 -
1. 동시성 프로그래밍으로 인한 성능 향상을 얻을 수 없다.
   심지어 과도한 락킹으로 성능이 하락되기도 한다. - 락을 획득하고 반납하는 시간

2. 고루틴을 완전히 멈추게 만드는 데드락 문제 발생
따라서 뮤텍스는 매우 조심하게 사용해야한다.
하지만 아예 뮤텍스를 사용하지 말아야 하는 것은 아니다.
뮤텍스는 가장 심플한 솔루션, 어떤 자원을 보호하기 위한
작은 범위 내에서 사용하는 것이 좋다. 

---------------------------------------
다른 자원 관리 기법

1. 영역을 나누는 방법
2. 역활을 나누는 방법

---------------------------------------
채널- 
채널은 고루틴간에 메시지를 전달할 수 있는 큐
make()로 채널 인스턴스 생성
var 채널변수 채널타입 = make(채널키워드 메시지타입, 큐빈자리수)

채널로 데이터 넣을때
채널변수 <- 데이터

뺄때
변수 <- 채널변수

채널이 빈자리가 없으면 데이터를 가져갈때 까지 대기한다.

좀비 고루틴 : 채널을 닫아주지 않아서 무한 대기하는 고루틴을 좀비 고루틴 혹은 고루틴 릭이라고 한다
채널을 close()로 닫아준다.

select문 여러 채널에서 동시에 데이터를 기다릴때  사용함
-------------------------------------
time 패키지의 Tick()은 일정 간격으로 신호를 주는 채널을 반환, 
After()는 일정 시간 대기후 한번만 신호룰 주는 채널 반환



